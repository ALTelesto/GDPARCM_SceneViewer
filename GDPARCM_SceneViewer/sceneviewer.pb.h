// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: sceneviewer.proto
// Protobuf C++ Version: 5.29.3

#ifndef sceneviewer_2eproto_2epb_2eh
#define sceneviewer_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sceneviewer_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sceneviewer_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_sceneviewer_2eproto;
namespace sceneviewer {
class Mesh;
struct MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Scene;
struct SceneDefaultTypeInternal;
extern SceneDefaultTypeInternal _Scene_default_instance_;
class SceneRequest;
struct SceneRequestDefaultTypeInternal;
extern SceneRequestDefaultTypeInternal _SceneRequest_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class Vertex;
struct VertexDefaultTypeInternal;
extern VertexDefaultTypeInternal _Vertex_default_instance_;
}  // namespace sceneviewer
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace sceneviewer {
enum SceneID : int {
  SCENE_0 = 0,
  SCENE_1 = 1,
  SCENE_2 = 2,
  SCENE_3 = 3,
  SCENE_4 = 4,
  SceneID_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SceneID_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SceneID_IsValid(int value);
extern const uint32_t SceneID_internal_data_[];
constexpr SceneID SceneID_MIN = static_cast<SceneID>(0);
constexpr SceneID SceneID_MAX = static_cast<SceneID>(4);
constexpr int SceneID_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
SceneID_descriptor();
template <typename T>
const std::string& SceneID_Name(T value) {
  static_assert(std::is_same<T, SceneID>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SceneID_Name().");
  return SceneID_Name(static_cast<SceneID>(value));
}
template <>
inline const std::string& SceneID_Name(SceneID value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SceneID_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SceneID_Parse(absl::string_view name, SceneID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneID>(
      SceneID_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Vector3 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sceneviewer.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vector3* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vector3));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector3(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vector3(const Vector3& from) : Vector3(nullptr, from) {}
  inline Vector3(Vector3&& from) noexcept
      : Vector3(nullptr, std::move(from)) {}
  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
        &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Vector3& a, Vector3& b) { a.Swap(&b); }
  inline void Swap(Vector3* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vector3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector3& from) { Vector3::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vector3* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sceneviewer.Vector3"; }

 protected:
  explicit Vector3(::google::protobuf::Arena* arena);
  Vector3(::google::protobuf::Arena* arena, const Vector3& from);
  Vector3(::google::protobuf::Arena* arena, Vector3&& from) noexcept
      : Vector3(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:sceneviewer.Vector3)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vector3& from_msg);
    float x_;
    float y_;
    float z_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sceneviewer_2eproto;
};
// -------------------------------------------------------------------

class SceneRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sceneviewer.SceneRequest) */ {
 public:
  inline SceneRequest() : SceneRequest(nullptr) {}
  ~SceneRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SceneRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SceneRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SceneRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SceneRequest(const SceneRequest& from) : SceneRequest(nullptr, from) {}
  inline SceneRequest(SceneRequest&& from) noexcept
      : SceneRequest(nullptr, std::move(from)) {}
  inline SceneRequest& operator=(const SceneRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneRequest& operator=(SceneRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SceneRequest* internal_default_instance() {
    return reinterpret_cast<const SceneRequest*>(
        &_SceneRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SceneRequest& a, SceneRequest& b) { a.Swap(&b); }
  inline void Swap(SceneRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SceneRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SceneRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SceneRequest& from) { SceneRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SceneRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sceneviewer.SceneRequest"; }

 protected:
  explicit SceneRequest(::google::protobuf::Arena* arena);
  SceneRequest(::google::protobuf::Arena* arena, const SceneRequest& from);
  SceneRequest(::google::protobuf::Arena* arena, SceneRequest&& from) noexcept
      : SceneRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSceneIdFieldNumber = 1,
  };
  // .sceneviewer.SceneID scene_id = 1;
  void clear_scene_id() ;
  ::sceneviewer::SceneID scene_id() const;
  void set_scene_id(::sceneviewer::SceneID value);

  private:
  ::sceneviewer::SceneID _internal_scene_id() const;
  void _internal_set_scene_id(::sceneviewer::SceneID value);

  public:
  // @@protoc_insertion_point(class_scope:sceneviewer.SceneRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SceneRequest& from_msg);
    int scene_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sceneviewer_2eproto;
};
// -------------------------------------------------------------------

class Vertex final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sceneviewer.Vertex) */ {
 public:
  inline Vertex() : Vertex(nullptr) {}
  ~Vertex() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vertex* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vertex));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vertex(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vertex(const Vertex& from) : Vertex(nullptr, from) {}
  inline Vertex(Vertex&& from) noexcept
      : Vertex(nullptr, std::move(from)) {}
  inline Vertex& operator=(const Vertex& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vertex& operator=(Vertex&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vertex& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vertex* internal_default_instance() {
    return reinterpret_cast<const Vertex*>(
        &_Vertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Vertex& a, Vertex& b) { a.Swap(&b); }
  inline void Swap(Vertex* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vertex* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vertex* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vertex>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vertex& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vertex& from) { Vertex::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vertex* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sceneviewer.Vertex"; }

 protected:
  explicit Vertex(::google::protobuf::Arena* arena);
  Vertex(::google::protobuf::Arena* arena, const Vertex& from);
  Vertex(::google::protobuf::Arena* arena, Vertex&& from) noexcept
      : Vertex(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kNormalFieldNumber = 2,
  };
  // .sceneviewer.Vector3 position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::sceneviewer::Vector3& position() const;
  PROTOBUF_NODISCARD ::sceneviewer::Vector3* release_position();
  ::sceneviewer::Vector3* mutable_position();
  void set_allocated_position(::sceneviewer::Vector3* value);
  void unsafe_arena_set_allocated_position(::sceneviewer::Vector3* value);
  ::sceneviewer::Vector3* unsafe_arena_release_position();

  private:
  const ::sceneviewer::Vector3& _internal_position() const;
  ::sceneviewer::Vector3* _internal_mutable_position();

  public:
  // .sceneviewer.Vector3 normal = 2;
  bool has_normal() const;
  void clear_normal() ;
  const ::sceneviewer::Vector3& normal() const;
  PROTOBUF_NODISCARD ::sceneviewer::Vector3* release_normal();
  ::sceneviewer::Vector3* mutable_normal();
  void set_allocated_normal(::sceneviewer::Vector3* value);
  void unsafe_arena_set_allocated_normal(::sceneviewer::Vector3* value);
  ::sceneviewer::Vector3* unsafe_arena_release_normal();

  private:
  const ::sceneviewer::Vector3& _internal_normal() const;
  ::sceneviewer::Vector3* _internal_mutable_normal();

  public:
  // @@protoc_insertion_point(class_scope:sceneviewer.Vertex)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vertex& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sceneviewer::Vector3* position_;
    ::sceneviewer::Vector3* normal_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sceneviewer_2eproto;
};
// -------------------------------------------------------------------

class Mesh final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sceneviewer.Mesh) */ {
 public:
  inline Mesh() : Mesh(nullptr) {}
  ~Mesh() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Mesh* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Mesh));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Mesh(
      ::google::protobuf::internal::ConstantInitialized);

  inline Mesh(const Mesh& from) : Mesh(nullptr, from) {}
  inline Mesh(Mesh&& from) noexcept
      : Mesh(nullptr, std::move(from)) {}
  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh& operator=(Mesh&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mesh& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mesh* internal_default_instance() {
    return reinterpret_cast<const Mesh*>(
        &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Mesh& a, Mesh& b) { a.Swap(&b); }
  inline void Swap(Mesh* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mesh* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Mesh>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Mesh& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Mesh& from) { Mesh::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Mesh* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sceneviewer.Mesh"; }

 protected:
  explicit Mesh(::google::protobuf::Arena* arena);
  Mesh(::google::protobuf::Arena* arena, const Mesh& from);
  Mesh(::google::protobuf::Arena* arena, Mesh&& from) noexcept
      : Mesh(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVerticesFieldNumber = 1,
    kIndicesFieldNumber = 2,
  };
  // repeated .sceneviewer.Vertex vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;

  public:
  void clear_vertices() ;
  ::sceneviewer::Vertex* mutable_vertices(int index);
  ::google::protobuf::RepeatedPtrField<::sceneviewer::Vertex>* mutable_vertices();

  private:
  const ::google::protobuf::RepeatedPtrField<::sceneviewer::Vertex>& _internal_vertices() const;
  ::google::protobuf::RepeatedPtrField<::sceneviewer::Vertex>* _internal_mutable_vertices();
  public:
  const ::sceneviewer::Vertex& vertices(int index) const;
  ::sceneviewer::Vertex* add_vertices();
  const ::google::protobuf::RepeatedPtrField<::sceneviewer::Vertex>& vertices() const;
  // repeated uint32 indices = 2;
  int indices_size() const;
  private:
  int _internal_indices_size() const;

  public:
  void clear_indices() ;
  ::uint32_t indices(int index) const;
  void set_indices(int index, ::uint32_t value);
  void add_indices(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& indices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_indices();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_indices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_indices();

  public:
  // @@protoc_insertion_point(class_scope:sceneviewer.Mesh)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Mesh& from_msg);
    ::google::protobuf::RepeatedPtrField< ::sceneviewer::Vertex > vertices_;
    ::google::protobuf::RepeatedField<::uint32_t> indices_;
    ::google::protobuf::internal::CachedSize _indices_cached_byte_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sceneviewer_2eproto;
};
// -------------------------------------------------------------------

class Model final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sceneviewer.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Model* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Model));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Model(
      ::google::protobuf::internal::ConstantInitialized);

  inline Model(const Model& from) : Model(nullptr, from) {}
  inline Model(Model&& from) noexcept
      : Model(nullptr, std::move(from)) {}
  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
        &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Model& a, Model& b) { a.Swap(&b); }
  inline void Swap(Model* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Model>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Model& from) { Model::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Model* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sceneviewer.Model"; }

 protected:
  explicit Model(::google::protobuf::Arena* arena);
  Model(::google::protobuf::Arena* arena, const Model& from);
  Model(::google::protobuf::Arena* arena, Model&& from) noexcept
      : Model(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMeshFieldNumber = 1,
    kPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kScaleFieldNumber = 4,
  };
  // .sceneviewer.Mesh mesh = 1;
  bool has_mesh() const;
  void clear_mesh() ;
  const ::sceneviewer::Mesh& mesh() const;
  PROTOBUF_NODISCARD ::sceneviewer::Mesh* release_mesh();
  ::sceneviewer::Mesh* mutable_mesh();
  void set_allocated_mesh(::sceneviewer::Mesh* value);
  void unsafe_arena_set_allocated_mesh(::sceneviewer::Mesh* value);
  ::sceneviewer::Mesh* unsafe_arena_release_mesh();

  private:
  const ::sceneviewer::Mesh& _internal_mesh() const;
  ::sceneviewer::Mesh* _internal_mutable_mesh();

  public:
  // .sceneviewer.Vector3 position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::sceneviewer::Vector3& position() const;
  PROTOBUF_NODISCARD ::sceneviewer::Vector3* release_position();
  ::sceneviewer::Vector3* mutable_position();
  void set_allocated_position(::sceneviewer::Vector3* value);
  void unsafe_arena_set_allocated_position(::sceneviewer::Vector3* value);
  ::sceneviewer::Vector3* unsafe_arena_release_position();

  private:
  const ::sceneviewer::Vector3& _internal_position() const;
  ::sceneviewer::Vector3* _internal_mutable_position();

  public:
  // .sceneviewer.Vector3 rotation = 3;
  bool has_rotation() const;
  void clear_rotation() ;
  const ::sceneviewer::Vector3& rotation() const;
  PROTOBUF_NODISCARD ::sceneviewer::Vector3* release_rotation();
  ::sceneviewer::Vector3* mutable_rotation();
  void set_allocated_rotation(::sceneviewer::Vector3* value);
  void unsafe_arena_set_allocated_rotation(::sceneviewer::Vector3* value);
  ::sceneviewer::Vector3* unsafe_arena_release_rotation();

  private:
  const ::sceneviewer::Vector3& _internal_rotation() const;
  ::sceneviewer::Vector3* _internal_mutable_rotation();

  public:
  // .sceneviewer.Vector3 scale = 4;
  bool has_scale() const;
  void clear_scale() ;
  const ::sceneviewer::Vector3& scale() const;
  PROTOBUF_NODISCARD ::sceneviewer::Vector3* release_scale();
  ::sceneviewer::Vector3* mutable_scale();
  void set_allocated_scale(::sceneviewer::Vector3* value);
  void unsafe_arena_set_allocated_scale(::sceneviewer::Vector3* value);
  ::sceneviewer::Vector3* unsafe_arena_release_scale();

  private:
  const ::sceneviewer::Vector3& _internal_scale() const;
  ::sceneviewer::Vector3* _internal_mutable_scale();

  public:
  // @@protoc_insertion_point(class_scope:sceneviewer.Model)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Model& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::sceneviewer::Mesh* mesh_;
    ::sceneviewer::Vector3* position_;
    ::sceneviewer::Vector3* rotation_;
    ::sceneviewer::Vector3* scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sceneviewer_2eproto;
};
// -------------------------------------------------------------------

class Scene final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:sceneviewer.Scene) */ {
 public:
  inline Scene() : Scene(nullptr) {}
  ~Scene() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Scene* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Scene));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Scene(
      ::google::protobuf::internal::ConstantInitialized);

  inline Scene(const Scene& from) : Scene(nullptr, from) {}
  inline Scene(Scene&& from) noexcept
      : Scene(nullptr, std::move(from)) {}
  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scene& operator=(Scene&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Scene& default_instance() {
    return *internal_default_instance();
  }
  static inline const Scene* internal_default_instance() {
    return reinterpret_cast<const Scene*>(
        &_Scene_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Scene& a, Scene& b) { a.Swap(&b); }
  inline void Swap(Scene* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scene* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Scene* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Scene>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Scene& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Scene& from) { Scene::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Scene* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "sceneviewer.Scene"; }

 protected:
  explicit Scene(::google::protobuf::Arena* arena);
  Scene(::google::protobuf::Arena* arena, const Scene& from);
  Scene(::google::protobuf::Arena* arena, Scene&& from) noexcept
      : Scene(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kModelsFieldNumber = 1,
  };
  // repeated .sceneviewer.Model models = 1;
  int models_size() const;
  private:
  int _internal_models_size() const;

  public:
  void clear_models() ;
  ::sceneviewer::Model* mutable_models(int index);
  ::google::protobuf::RepeatedPtrField<::sceneviewer::Model>* mutable_models();

  private:
  const ::google::protobuf::RepeatedPtrField<::sceneviewer::Model>& _internal_models() const;
  ::google::protobuf::RepeatedPtrField<::sceneviewer::Model>* _internal_mutable_models();
  public:
  const ::sceneviewer::Model& models(int index) const;
  ::sceneviewer::Model* add_models();
  const ::google::protobuf::RepeatedPtrField<::sceneviewer::Model>& models() const;
  // @@protoc_insertion_point(class_scope:sceneviewer.Scene)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Scene& from_msg);
    ::google::protobuf::RepeatedPtrField< ::sceneviewer::Model > models_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sceneviewer_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:sceneviewer.Vector3.x)
  return _internal_x();
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:sceneviewer.Vector3.x)
}
inline float Vector3::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector3::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector3::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:sceneviewer.Vector3.y)
  return _internal_y();
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:sceneviewer.Vector3.y)
}
inline float Vector3::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector3::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Vector3::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:sceneviewer.Vector3.z)
  return _internal_z();
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:sceneviewer.Vector3.z)
}
inline float Vector3::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vector3::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Vertex

// .sceneviewer.Vector3 position = 1;
inline bool Vertex::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Vertex::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sceneviewer::Vector3& Vertex::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sceneviewer::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::sceneviewer::Vector3&>(::sceneviewer::_Vector3_default_instance_);
}
inline const ::sceneviewer::Vector3& Vertex::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sceneviewer.Vertex.position)
  return _internal_position();
}
inline void Vertex::unsafe_arena_set_allocated_position(::sceneviewer::Vector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::sceneviewer::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sceneviewer.Vertex.position)
}
inline ::sceneviewer::Vector3* Vertex::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sceneviewer::Vector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sceneviewer::Vector3* Vertex::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sceneviewer.Vertex.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sceneviewer::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::sceneviewer::Vector3* Vertex::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sceneviewer::Vector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::sceneviewer::Vector3*>(p);
  }
  return _impl_.position_;
}
inline ::sceneviewer::Vector3* Vertex::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sceneviewer::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:sceneviewer.Vertex.position)
  return _msg;
}
inline void Vertex::set_allocated_position(::sceneviewer::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::sceneviewer::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:sceneviewer.Vertex.position)
}

// .sceneviewer.Vector3 normal = 2;
inline bool Vertex::has_normal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.normal_ != nullptr);
  return value;
}
inline void Vertex::clear_normal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sceneviewer::Vector3& Vertex::_internal_normal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sceneviewer::Vector3* p = _impl_.normal_;
  return p != nullptr ? *p : reinterpret_cast<const ::sceneviewer::Vector3&>(::sceneviewer::_Vector3_default_instance_);
}
inline const ::sceneviewer::Vector3& Vertex::normal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sceneviewer.Vertex.normal)
  return _internal_normal();
}
inline void Vertex::unsafe_arena_set_allocated_normal(::sceneviewer::Vector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.normal_);
  }
  _impl_.normal_ = reinterpret_cast<::sceneviewer::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sceneviewer.Vertex.normal)
}
inline ::sceneviewer::Vector3* Vertex::release_normal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sceneviewer::Vector3* released = _impl_.normal_;
  _impl_.normal_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sceneviewer::Vector3* Vertex::unsafe_arena_release_normal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sceneviewer.Vertex.normal)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sceneviewer::Vector3* temp = _impl_.normal_;
  _impl_.normal_ = nullptr;
  return temp;
}
inline ::sceneviewer::Vector3* Vertex::_internal_mutable_normal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.normal_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sceneviewer::Vector3>(GetArena());
    _impl_.normal_ = reinterpret_cast<::sceneviewer::Vector3*>(p);
  }
  return _impl_.normal_;
}
inline ::sceneviewer::Vector3* Vertex::mutable_normal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sceneviewer::Vector3* _msg = _internal_mutable_normal();
  // @@protoc_insertion_point(field_mutable:sceneviewer.Vertex.normal)
  return _msg;
}
inline void Vertex::set_allocated_normal(::sceneviewer::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.normal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.normal_ = reinterpret_cast<::sceneviewer::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:sceneviewer.Vertex.normal)
}

// -------------------------------------------------------------------

// Mesh

// repeated .sceneviewer.Vertex vertices = 1;
inline int Mesh::_internal_vertices_size() const {
  return _internal_vertices().size();
}
inline int Mesh::vertices_size() const {
  return _internal_vertices_size();
}
inline void Mesh::clear_vertices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vertices_.Clear();
}
inline ::sceneviewer::Vertex* Mesh::mutable_vertices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sceneviewer.Mesh.vertices)
  return _internal_mutable_vertices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sceneviewer::Vertex>* Mesh::mutable_vertices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sceneviewer.Mesh.vertices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vertices();
}
inline const ::sceneviewer::Vertex& Mesh::vertices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sceneviewer.Mesh.vertices)
  return _internal_vertices().Get(index);
}
inline ::sceneviewer::Vertex* Mesh::add_vertices() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sceneviewer::Vertex* _add = _internal_mutable_vertices()->Add();
  // @@protoc_insertion_point(field_add:sceneviewer.Mesh.vertices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sceneviewer::Vertex>& Mesh::vertices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sceneviewer.Mesh.vertices)
  return _internal_vertices();
}
inline const ::google::protobuf::RepeatedPtrField<::sceneviewer::Vertex>&
Mesh::_internal_vertices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vertices_;
}
inline ::google::protobuf::RepeatedPtrField<::sceneviewer::Vertex>*
Mesh::_internal_mutable_vertices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vertices_;
}

// repeated uint32 indices = 2;
inline int Mesh::_internal_indices_size() const {
  return _internal_indices().size();
}
inline int Mesh::indices_size() const {
  return _internal_indices_size();
}
inline void Mesh::clear_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indices_.Clear();
}
inline ::uint32_t Mesh::indices(int index) const {
  // @@protoc_insertion_point(field_get:sceneviewer.Mesh.indices)
  return _internal_indices().Get(index);
}
inline void Mesh::set_indices(int index, ::uint32_t value) {
  _internal_mutable_indices()->Set(index, value);
  // @@protoc_insertion_point(field_set:sceneviewer.Mesh.indices)
}
inline void Mesh::add_indices(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_indices()->Add(value);
  // @@protoc_insertion_point(field_add:sceneviewer.Mesh.indices)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Mesh::indices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sceneviewer.Mesh.indices)
  return _internal_indices();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Mesh::mutable_indices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sceneviewer.Mesh.indices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_indices();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Mesh::_internal_indices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.indices_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Mesh::_internal_mutable_indices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.indices_;
}

// -------------------------------------------------------------------

// Model

// .sceneviewer.Mesh mesh = 1;
inline bool Model::has_mesh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mesh_ != nullptr);
  return value;
}
inline void Model::clear_mesh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mesh_ != nullptr) _impl_.mesh_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sceneviewer::Mesh& Model::_internal_mesh() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sceneviewer::Mesh* p = _impl_.mesh_;
  return p != nullptr ? *p : reinterpret_cast<const ::sceneviewer::Mesh&>(::sceneviewer::_Mesh_default_instance_);
}
inline const ::sceneviewer::Mesh& Model::mesh() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sceneviewer.Model.mesh)
  return _internal_mesh();
}
inline void Model::unsafe_arena_set_allocated_mesh(::sceneviewer::Mesh* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mesh_);
  }
  _impl_.mesh_ = reinterpret_cast<::sceneviewer::Mesh*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sceneviewer.Model.mesh)
}
inline ::sceneviewer::Mesh* Model::release_mesh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sceneviewer::Mesh* released = _impl_.mesh_;
  _impl_.mesh_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sceneviewer::Mesh* Model::unsafe_arena_release_mesh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sceneviewer.Model.mesh)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sceneviewer::Mesh* temp = _impl_.mesh_;
  _impl_.mesh_ = nullptr;
  return temp;
}
inline ::sceneviewer::Mesh* Model::_internal_mutable_mesh() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mesh_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sceneviewer::Mesh>(GetArena());
    _impl_.mesh_ = reinterpret_cast<::sceneviewer::Mesh*>(p);
  }
  return _impl_.mesh_;
}
inline ::sceneviewer::Mesh* Model::mutable_mesh() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::sceneviewer::Mesh* _msg = _internal_mutable_mesh();
  // @@protoc_insertion_point(field_mutable:sceneviewer.Model.mesh)
  return _msg;
}
inline void Model::set_allocated_mesh(::sceneviewer::Mesh* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.mesh_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.mesh_ = reinterpret_cast<::sceneviewer::Mesh*>(value);
  // @@protoc_insertion_point(field_set_allocated:sceneviewer.Model.mesh)
}

// .sceneviewer.Vector3 position = 2;
inline bool Model::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Model::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sceneviewer::Vector3& Model::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sceneviewer::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::sceneviewer::Vector3&>(::sceneviewer::_Vector3_default_instance_);
}
inline const ::sceneviewer::Vector3& Model::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sceneviewer.Model.position)
  return _internal_position();
}
inline void Model::unsafe_arena_set_allocated_position(::sceneviewer::Vector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::sceneviewer::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sceneviewer.Model.position)
}
inline ::sceneviewer::Vector3* Model::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sceneviewer::Vector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sceneviewer::Vector3* Model::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sceneviewer.Model.position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sceneviewer::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::sceneviewer::Vector3* Model::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sceneviewer::Vector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::sceneviewer::Vector3*>(p);
  }
  return _impl_.position_;
}
inline ::sceneviewer::Vector3* Model::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::sceneviewer::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:sceneviewer.Model.position)
  return _msg;
}
inline void Model::set_allocated_position(::sceneviewer::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_ = reinterpret_cast<::sceneviewer::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:sceneviewer.Model.position)
}

// .sceneviewer.Vector3 rotation = 3;
inline bool Model::has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline void Model::clear_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sceneviewer::Vector3& Model::_internal_rotation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sceneviewer::Vector3* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::sceneviewer::Vector3&>(::sceneviewer::_Vector3_default_instance_);
}
inline const ::sceneviewer::Vector3& Model::rotation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sceneviewer.Model.rotation)
  return _internal_rotation();
}
inline void Model::unsafe_arena_set_allocated_rotation(::sceneviewer::Vector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = reinterpret_cast<::sceneviewer::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sceneviewer.Model.rotation)
}
inline ::sceneviewer::Vector3* Model::release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sceneviewer::Vector3* released = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sceneviewer::Vector3* Model::unsafe_arena_release_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sceneviewer.Model.rotation)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sceneviewer::Vector3* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::sceneviewer::Vector3* Model::_internal_mutable_rotation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rotation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sceneviewer::Vector3>(GetArena());
    _impl_.rotation_ = reinterpret_cast<::sceneviewer::Vector3*>(p);
  }
  return _impl_.rotation_;
}
inline ::sceneviewer::Vector3* Model::mutable_rotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::sceneviewer::Vector3* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:sceneviewer.Model.rotation)
  return _msg;
}
inline void Model::set_allocated_rotation(::sceneviewer::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rotation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.rotation_ = reinterpret_cast<::sceneviewer::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:sceneviewer.Model.rotation)
}

// .sceneviewer.Vector3 scale = 4;
inline bool Model::has_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scale_ != nullptr);
  return value;
}
inline void Model::clear_scale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scale_ != nullptr) _impl_.scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sceneviewer::Vector3& Model::_internal_scale() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::sceneviewer::Vector3* p = _impl_.scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::sceneviewer::Vector3&>(::sceneviewer::_Vector3_default_instance_);
}
inline const ::sceneviewer::Vector3& Model::scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sceneviewer.Model.scale)
  return _internal_scale();
}
inline void Model::unsafe_arena_set_allocated_scale(::sceneviewer::Vector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scale_);
  }
  _impl_.scale_ = reinterpret_cast<::sceneviewer::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sceneviewer.Model.scale)
}
inline ::sceneviewer::Vector3* Model::release_scale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sceneviewer::Vector3* released = _impl_.scale_;
  _impl_.scale_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::sceneviewer::Vector3* Model::unsafe_arena_release_scale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:sceneviewer.Model.scale)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sceneviewer::Vector3* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
  return temp;
}
inline ::sceneviewer::Vector3* Model::_internal_mutable_scale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.scale_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::sceneviewer::Vector3>(GetArena());
    _impl_.scale_ = reinterpret_cast<::sceneviewer::Vector3*>(p);
  }
  return _impl_.scale_;
}
inline ::sceneviewer::Vector3* Model::mutable_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::sceneviewer::Vector3* _msg = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:sceneviewer.Model.scale)
  return _msg;
}
inline void Model::set_allocated_scale(::sceneviewer::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.scale_ = reinterpret_cast<::sceneviewer::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:sceneviewer.Model.scale)
}

// -------------------------------------------------------------------

// SceneRequest

// .sceneviewer.SceneID scene_id = 1;
inline void SceneRequest::clear_scene_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scene_id_ = 0;
}
inline ::sceneviewer::SceneID SceneRequest::scene_id() const {
  // @@protoc_insertion_point(field_get:sceneviewer.SceneRequest.scene_id)
  return _internal_scene_id();
}
inline void SceneRequest::set_scene_id(::sceneviewer::SceneID value) {
  _internal_set_scene_id(value);
  // @@protoc_insertion_point(field_set:sceneviewer.SceneRequest.scene_id)
}
inline ::sceneviewer::SceneID SceneRequest::_internal_scene_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::sceneviewer::SceneID>(_impl_.scene_id_);
}
inline void SceneRequest::_internal_set_scene_id(::sceneviewer::SceneID value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scene_id_ = value;
}

// -------------------------------------------------------------------

// Scene

// repeated .sceneviewer.Model models = 1;
inline int Scene::_internal_models_size() const {
  return _internal_models().size();
}
inline int Scene::models_size() const {
  return _internal_models_size();
}
inline void Scene::clear_models() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.models_.Clear();
}
inline ::sceneviewer::Model* Scene::mutable_models(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sceneviewer.Scene.models)
  return _internal_mutable_models()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sceneviewer::Model>* Scene::mutable_models()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sceneviewer.Scene.models)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_models();
}
inline const ::sceneviewer::Model& Scene::models(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sceneviewer.Scene.models)
  return _internal_models().Get(index);
}
inline ::sceneviewer::Model* Scene::add_models() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::sceneviewer::Model* _add = _internal_mutable_models()->Add();
  // @@protoc_insertion_point(field_add:sceneviewer.Scene.models)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sceneviewer::Model>& Scene::models() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sceneviewer.Scene.models)
  return _internal_models();
}
inline const ::google::protobuf::RepeatedPtrField<::sceneviewer::Model>&
Scene::_internal_models() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.models_;
}
inline ::google::protobuf::RepeatedPtrField<::sceneviewer::Model>*
Scene::_internal_mutable_models() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.models_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace sceneviewer


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::sceneviewer::SceneID> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sceneviewer::SceneID>() {
  return ::sceneviewer::SceneID_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // sceneviewer_2eproto_2epb_2eh
